var searchIndex = {};
searchIndex["rust_boost_bin"] = {"doc":"","items":[],"paths":[]};
searchIndex["rustboost"] = {"doc":"rustboost is an implementation of TMSN for boosting.","items":[[0,"bins","rustboost","The values of percentiles on each feature dimension.",null,null],[3,"Bins","rustboost::bins","The percentiles of a specific feature dimension, which would be used as the candidates weak rules on that dimension.",null,null],[5,"create_bins","","Find the percentiles of the feature in the range specified by `range`. ",null,{"inputs":[{"name":"usize"},{"name":"usize"},{"name":"range"},{"name":"bufferloader"}],"output":{"generics":["bins"],"name":"vec"}}],[11,"len","","Return the number of thresholds. ",0,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"get_vals","","Return the vector of thresholds.",0,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[0,"boosting","rustboost","The implementation of the AdaBoost algorithm with early stopping rule.",null,null],[3,"Boosting","rustboost::boosting","The boosting algorithm. It contains two functions, one for starting the network communication, the other for starting the training procedure.",null,null],[11,"new","","Create a boosting training class.",1,{"inputs":[{"name":"bufferloader"},{"generics":["usize"],"name":"range"},{"name":"usize"},{"name":"usize"},{"name":"f32"}],"output":{"name":"boosting"}}],[11,"enable_network","","Enable network communication. `name` is the name of this worker, which can be arbitrary and is only used for debugging purpose. `remote_ips` is the vector of IPs of neighbor workers. `port` is the port number that used for network communication.",1,{"inputs":[{"name":"self"},{"name":"string"},{"name":"vec"},{"name":"u16"}],"output":null}],[11,"training","","Start training the boosting algorithm.",1,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"u32"}],"output":null}],[0,"commons","rustboost","Common functions and classes.",null,null],[5,"get_weight","rustboost::commons","",null,{"inputs":[{"name":"example"},{"name":"f32"}],"output":{"name":"f32"}}],[5,"get_weights","","",null,null],[5,"get_absolute_weights","","",null,null],[5,"get_relative_weights","","",null,null],[5,"get_bound","","",null,{"inputs":[{"name":"f32"},{"name":"f32"}],"output":{"generics":["f32"],"name":"option"}}],[5,"get_symmetric_label","","",null,{"inputs":[{"name":"example"}],"output":{"name":"f32"}}],[5,"max","","",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"min","","",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"is_zero","","",null,{"inputs":[{"name":"f32"}],"output":{"name":"bool"}}],[5,"get_sign","","",null,{"inputs":[{"name":"f64"}],"output":{"name":"i8"}}],[5,"is_positive","","",null,{"inputs":[{"name":"f32"}],"output":{"name":"bool"}}],[0,"performance_monitor","","",null,null],[3,"PerformanceMonitor","rustboost::commons::performance_monitor","",null,null],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",2,{"inputs":[],"output":{"name":"performancemonitor"}}],[11,"reset","","",2,{"inputs":[{"name":"self"}],"output":null}],[11,"start","","",2,{"inputs":[{"name":"self"}],"output":null}],[11,"resume","","",2,{"inputs":[{"name":"self"}],"output":null}],[11,"update","","",2,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"pause","","",2,{"inputs":[{"name":"self"}],"output":null}],[11,"get_performance","","",2,null],[11,"reset_last_check","","",2,{"inputs":[{"name":"self"}],"output":null}],[11,"get_duration","","",2,{"inputs":[{"name":"self"}],"output":{"name":"f32"}}],[0,"io","rustboost::commons","",null,null],[5,"create_bufreader","rustboost::commons::io","",null,{"inputs":[{"name":"string"}],"output":{"generics":["file"],"name":"bufreader"}}],[5,"create_bufwriter","","",null,{"inputs":[{"name":"string"}],"output":{"generics":["file"],"name":"bufwriter"}}],[5,"read_k_lines","","",null,{"inputs":[{"name":"bufreader"},{"name":"usize"}],"output":{"generics":["string"],"name":"vec"}}],[5,"read_k_labeled_data","","",null,{"inputs":[{"name":"bufreader"},{"name":"usize"},{"name":"tfeature"},{"name":"usize"}],"output":{"generics":["labeleddata"],"name":"vec"}}],[5,"read_k_labeled_data_from_binary_file","","",null,{"inputs":[{"name":"bufreader"},{"name":"usize"},{"name":"usize"}],"output":{"generics":["example"],"name":"vec"}}],[5,"write_to_binary_file","","",null,{"inputs":[{"name":"bufwriter"},{"name":"example"}],"output":{"name":"usize"}}],[5,"write_to_text_file","","",null,{"inputs":[{"name":"bufwriter"},{"name":"string"}],"output":null}],[5,"parse_libsvm_one_line","","",null,{"inputs":[{"name":"string"},{"name":"tfeature"},{"name":"usize"}],"output":{"name":"labeleddata"}}],[5,"parse_libsvm","","",null,{"inputs":[{"name":"vec"},{"name":"tfeature"},{"name":"usize"}],"output":{"generics":["labeleddata"],"name":"vec"}}],[6,"TFeature","rustboost::commons","",null,null],[6,"TLabel","","",null,null],[6,"Example","","",null,null],[6,"ExampleInSampleSet","","",null,null],[6,"ExampleWithScore","","",null,null],[6,"Model","","",null,null],[6,"ModelScore","","",null,null],[6,"LossFunc","","",null,null],[0,"config","rustboost","Configurations that can be stored in a separate JSON file.",null,null],[3,"Config","rustboost::config","Configuration of the RustBoost",null,null],[11,"get_network","","Return the vector of the IPs of the neighbor workers",3,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"get_data_dir","","Return the path to the directory that contains the training data",3,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[0,"buffer_loader","rustboost","A data loader with two independent caches. Alternatively, we use one of the caches to feed data to the boosting algorithm, and the other to load next sample set.",null,null],[3,"BufferLoader","rustboost::buffer_loader","Double-buffered sample set. It consists of two buffers stores in memory. One of the buffer is used for providing examples to the boosting algorithm, meanwhile the other would receive new examples from the sampler module. Once the other buffer is filled, the functions of the two buffers switch so that the sample set used for training would be updated periodically.",null,null],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new BufferLoader.",4,{"inputs":[{"name":"usize"},{"name":"usize"},{"generics":["examplewithscore"],"name":"receiver"},{"name":"bool"}],"output":{"name":"bufferloader"}}],[11,"load","","Create the first sample set reading from the sampler. This function blocks until the first sample set is created.",4,{"inputs":[{"name":"self"}],"output":null}],[11,"get_num_batches","","Return the number of batches (i.e. the number of function calls to `fetch_next_batch`) before exhausting the current sample set.",4,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"get_curr_batch","","Get current batch of examples.",4,null],[11,"fetch_next_batch","","Read next batch of examples.",4,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[11,"update_scores","","Update the scores of the examples in the current batch using `model`.",4,{"inputs":[{"name":"self"},{"name":"model"}],"output":null}],[11,"get_ess","","Get the estimate of the effective sample size of the current sample set.",4,{"inputs":[{"name":"self"}],"output":{"generics":["f32"],"name":"option"}}],[0,"labeled_data","rustboost","The class of the training examples.",null,null],[3,"LabeledData","rustboost::labeled_data","Training example. It consists of two fields: `features` and `label`.",null,null],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"labeleddata"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",5,{"inputs":[{"name":"vec"},{"name":"tlabel"}],"output":{"name":"labeleddata"}}],[11,"get_features","","",5,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"get_label","","",5,{"inputs":[{"name":"self"}],"output":{"name":"tlabel"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"labeleddata"}],"output":{"name":"bool"}}],[0,"network","rustboost","Manage network I/O",null,null],[5,"start_network","rustboost::network","Start the network module on the current computer.",null,{"inputs":[{"name":"string"},{"name":"vec"},{"name":"u16"},{"generics":["modelscore"],"name":"sender"},{"generics":["modelscore"],"name":"receiver"}],"output":null}],[0,"sampler","rustboost","Sampling data from the stratified storage.",null,null],[5,"run_sampler","rustboost::sampler","Start the sampler.",null,{"inputs":[{"name":"usize"},{"name":"f32"},{"name":"usize"},{"generics":["examplewithscore"],"name":"receiver"},{"generics":["examplewithscore"],"name":"sender"},{"generics":["examplewithscore"],"name":"syncsender"},{"generics":["model"],"name":"receiver"}],"output":null}],[0,"stratified_storage","rustboost","A stratified storage structor that organize examples on disk according to their weights.",null,null],[5,"run_stratified","rustboost::stratified_storage","Start the stratified storage structure.",null,null],[0,"tree","rustboost","The class of the weak learner, namely a decision stump.",null,null],[3,"Tree","rustboost::tree","",null,null],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"tree"}}],[11,"new","","",6,{"inputs":[{"name":"u16"}],"output":{"name":"tree"}}],[11,"release","","",6,{"inputs":[{"name":"self"}],"output":null}],[11,"split","","",6,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"},{"name":"f32"},{"name":"f32"},{"name":"f32"}],"output":null}],[11,"add_prediction_to_score","","",6,{"inputs":[{"name":"self"},{"name":"vec"},{"name":"vec"}],"output":null}],[11,"get_leaf_prediction","","",6,{"inputs":[{"name":"self"},{"name":"example"}],"output":{"name":"f32"}}],[11,"eq","","",6,{"inputs":[{"name":"self"},{"name":"tree"}],"output":{"name":"bool"}}]],"paths":[[3,"Bins"],[3,"Boosting"],[3,"PerformanceMonitor"],[3,"Config"],[3,"BufferLoader"],[3,"LabeledData"],[3,"Tree"]]};
initSearch(searchIndex);
